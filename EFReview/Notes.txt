===================================
Code First with Existing Database
===================================

Process

Reverse Engineer - Existing DB -> Model
Use code first for any subsequent changes

Change model then use migrations to bring DB up to date

Benefits
- Full versioning of the database
- Less time wated in designers; just write code

1. Add ADO.NET Entity Data Model - named MyDBContext


Always work on small changes and small migrations

Big migrations may have errors...

Think like git commit

Modifying an existing column (renaming) is a dangerous
migration b/c EF will create new column and drop the old column
w/o copying the data so you have to make sure to copy data yourself
either with SQL command or change to RenameColumn function

=====================================
Downgrading a Database
=====================================

This would be used if currently working on a new feature but you need
to go back to a previous commit to work on a hotfix for production

You'd need to downgrade the Database via your migrations back to the version
that was in production so you can do your work.. 

update-database -TargetMigration:<NameOfMigration>

this will take database back to previous version

Flow here....

In current code, downgrade database to version of db for production
	update-database -TargetMigration:<NameOfMigration>

checkout production code - perform fixes

commit to production, merge changes to new feature branch

run update-database to return to current version of db
	update-database

NOTE: Always Go forward or backwards in db version via the latest version of source code

why?
	we want to restore to previous state, so we have to revert latest db state which is in our current source code
	if go back to previous version, we won't have latest migration to run down methods

===========================================
Overriding Code-First Conventions
===========================================

There are times when you want to override the OOTB coventions that EF provides for you..
for example, a string in .NET maps to a varchar(MAX) that allows nulls in DB
	this is OOTB behavior because strings are nullable in .NET

You might not want this behavior.. so you have two options.. either using..

Data Annotations (Attributes)
	or
Fluent API

Stick to one or the other approach and don't mix that way you only have to look in one
place for overrides
	Data Annotations (Domain Classes)
	Fluent API (DbContext)


On enterprise level app, stick with Fluent API
	that way domain model doesn't get noisy with database specific knowledge
	more code but better separation of concerns

On simple app, with small audience, you can use Data Annotations

=============================
Data Annotations
=============================

OOTB Conventions

Table Names
	Plural form of class names

	[Table("tbl_Course", Schema = "catalog")] - will map target table (optionally you can give Schema if not in dbo schema)
	public class Course

Column Names
	Same as properties

	[Column("sName", TypeName = "varchar")]
	public string Name {get; set;}

Primary Key
	A property named ID or [ClassName]ID

	[Key]
	[DatabaseGenerated(DatabaseGeneratedOption.None)]  // None, Identity and Computed
	public string ISBN { get; set; }

Composite Keys

public class OrderItem
{
	[Key]
	[Column(Order = 1)]
	public int OrderId { get; set; }

	[Key]
	[Column(Order = 2)]
	public int OrderItemId { get; set; }
}

Nulls
	A column is nullable if property is nullable

	[Required]
	public string Name { get; set;}

	[Required]
	public Author Author { get; set; }

Length of Strings
	MAX

	[MaxLength(255)]
	public string Name {get; set;}

Index

	[Index(IsUnique = true)]
	public string Name {get; set;}

Multiple Column Index
	[Index("IX_AuthorStudentsCount", 1)]
	public int AuthorId {get;set;}

	[Index("IX_AuthorStudentsCount", 2)]
	public int StudentsCount {get; set; }

Foreign Keys
	Need to create property for foreign key that you want
	Then use 1 of either of these data annotations to set new foreign key

	public class Course
	{
		//[ForeignKey("Author")]
		public int AuthorId {get; set;}

		//[ForeignKey("AuthorId")]
		public Author Author {get; set;}
	}