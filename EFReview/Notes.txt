Loading Related Objects

There are 3 ways -
	- Lazy Loading
	- Eager Loading
	- Explicit Loading

In order to get lazy loading you have to setup your navigational properties like so...
	public virtual ICollection<Tag> Tags { get; set; }

At runtime EF creates dynamic proxy
CourseProxy - class looks like original Coure call.. will override tag property like so..

if (_tags == null)
	_tags = context.LoadTags();

	return _tags;

1st time access because null will be initialized any time after
we will get in memory tags

In Debug, EF will load related items via lazy loading

Best Practices
- Use when loading an object graph is costly (a delay in app startup)
	- use lazy loading to only load main objects then load related objects when necessary
- Avoid in web applications
	- Because we always get new request/response data.. will cause unnessary round trip
	- Disable lazy load by setting to NOT be virtual

To turn off in DbContext do this,
	in constructor of DbContext,

	this.Configuration.LazyLoadingEnabled = false;

Avoid using virtual to define related objects

=============================
N + 1 Issue
=============================

N + 1 - To get N entites and their related entites, we'l end up with N + 1 queries

How this happens:
	Use EF to get all courses like this context.Courses.ToList();

	Then iterate over the courses and get Author name like this
		foreach (var course in Courses)
			course.Author.Name
	For each course item there will be another call to Database to get author info
		because Lazy Loading is turned on and we don't have Author info during initial Courses call

Be careful with Lazy Loading.. watch out for unnecessary queries

===============================
Eager Loading
==============================

Is opposite of Lazy Loading to prevent additioanl queries from Database

HOw to do:
	var courses = context.Courses.Include("Author").ToList();
		the query will join the courses table to get courses and authors
		but this is a bad coding practice because of magic string

	Better way
	using System.Data.Entity;

	var courses = context.Courses.Include(c => c.Author).ToList();

Multiple Levels

// all courses with their authors
// for single properties
context.Courses.Include(c => c.Author.Address);

// for collection properties
context.Courses.Include(a => a.Tags.Select(t => t.Moderator));

can be good and bad

Too Many Includes is BAD.. storing object that you don't need

Decide when to use Eager vs Lazy Loading

=================================
Explicit Loading
=================================
 
Eager Loading
- Uses JOINS
- One Round-Trip

Explicit
- Separarte queries
- Multiple Round-Trips

// MSDN way
context.Entry(author).Collection(a => a.Courses).Load();

// MOSH way
context.Courses.Where(c => c.AuthorId == author.Id && c.FullPrice == 0).Load();

var authors = context.Authors.ToList();
var authorIds = authors.Select(a => a.Id);

context.Courses.Where(c => authorIds.Contains(c.AuthorId) && c.FullPrice == 0).Load();



